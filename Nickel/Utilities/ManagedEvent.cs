using System;
using System.Collections.Generic;
using System.Reflection;

namespace Nickel;

/// <summary>
/// Manages a safe, ordered list of mod-specific event handlers, with each handler having separate <see cref="Exception"/> handling.
/// </summary>
/// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
public sealed class ManagedEvent<TEventArgs>
{
	/// <summary>
	/// Allows modifying the event args between calls to each event handler.
	/// </summary>
	/// <param name="previousSubscriber">The owner mod of the previously called handler, or <c>null</c> before the first invocation.</param>
	/// <param name="nextSubscriber">The owner mod of the next-to-be called handler, or <c>null</c> after the last invocation.</param>
	/// <param name="sender">The source of the event.</param>
	/// <param name="args">An object that contains the modified or original event data.</param>
	public delegate void ModifyEventArgsBetweenSubscribersDelegate(IModManifest? previousSubscriber, IModManifest? nextSubscriber, object? sender, ref TEventArgs args);

	/// <summary>Allows modifying the event args between calls to each event handler.</summary>
	/// <seealso cref="ModifyEventArgsBetweenSubscribersDelegate"/>
	public ModifyEventArgsBetweenSubscribersDelegate? ModifyEventArgsBetweenSubscribers { get; init; }

	private readonly OrderedList<ManagedEventHandler, double> Handlers = [];
	private readonly List<(ManagedEventsModification, ManagedEventHandler)> AwaitingModifications = [];
	private readonly Action<EventHandler<TEventArgs>, IModManifest, Exception>? ExceptionHandler;
	private bool IsRaising;

	/// <summary>
	/// Creates an instance of <see cref="ManagedEvent{TEventArgs}"/>.
	/// </summary>
	/// <param name="exceptionHandler">The function that handles any exceptions coming from the event handlers. If not provided, exceptions will still stop further event handlers from being called.</param>
	public ManagedEvent(Action<EventHandler<TEventArgs>, IModManifest, Exception>? exceptionHandler)
	{
		this.ExceptionHandler = exceptionHandler;
	}

	/// <summary>
	/// Subscribe an event handler for the given mod.
	/// </summary>
	/// <param name="handler">The event handler.</param>
	/// <param name="mod">The owning mod.</param>
	public void Add(EventHandler<TEventArgs> handler, IModManifest mod)
	{
		lock (this.Handlers)
		{
			var managedEventHandler = new ManagedEventHandler(mod, handler);
			if (this.IsRaising)
				this.AwaitingModifications.Add((ManagedEventsModification.Add, managedEventHandler));
			else
				this.ActuallyAdd(managedEventHandler);
		}
	}

	private void ActuallyAdd(ManagedEventHandler handler)
	{
		lock (this.Handlers)
		{
			var priority = handler.Handler.Method.GetCustomAttribute<EventPriorityAttribute>()?.Priority ?? 0;
			this.Handlers.Add(handler, -priority);
		}
	}

	/// <summary>
	/// Unsubscribe an event handler for the given mod.
	/// </summary>
	/// <param name="handler">The event handler.</param>
	/// <param name="mod">The owning mod.</param>
	public void Remove(EventHandler<TEventArgs> handler, IModManifest mod)
	{
		lock (this.Handlers)
		{
			var managedEventHandler = new ManagedEventHandler(mod, handler);
			if (this.IsRaising)
				this.AwaitingModifications.Add((ManagedEventsModification.Remove, managedEventHandler));
			else
				this.ActuallyRemove(managedEventHandler);
		}
	}

	private void ActuallyRemove(ManagedEventHandler handler)
	{
		lock (this.Handlers)
		{
			this.Handlers.Remove(handler);
		}
	}

	/// <summary>
	/// Raises the event by invoking each handler.
	/// </summary>
	/// <param name="sender">The source of the event.</param>
	/// <param name="args">An object that contains the event data. This event data can be modified between each handler invocation: see <see cref="ModifyEventArgsBetweenSubscribers"/>.</param>
	/// <returns>Modified or original event data.</returns>
	public TEventArgs Raise(object? sender, TEventArgs args)
	{
		lock (this.Handlers)
		{
			this.IsRaising = true;
			try
			{
				if (this.ExceptionHandler is not null)
				{
					IModManifest? previousSubscriber = null;
					foreach (var handler in this.Handlers)
					{
						try
						{
							this.ModifyEventArgsBetweenSubscribers?.Invoke(previousSubscriber, handler.Mod, sender, ref args);
							handler.Handler(sender, args);
						}
						catch (Exception e)
						{
							this.ExceptionHandler(handler.Handler, handler.Mod, e);
						}
						previousSubscriber = handler.Mod;
					}
					this.ModifyEventArgsBetweenSubscribers?.Invoke(previousSubscriber, null, sender, ref args);
				}
				else
				{
					IModManifest? previousSubscriber = null;
					foreach (var handler in this.Handlers)
					{
						this.ModifyEventArgsBetweenSubscribers?.Invoke(previousSubscriber, handler.Mod, sender, ref args);
						handler.Handler(sender, args);
						previousSubscriber = handler.Mod;
					}
					this.ModifyEventArgsBetweenSubscribers?.Invoke(previousSubscriber, null, sender, ref args);
				}
			}
			finally
			{
				this.IsRaising = false;
				this.RunAwaitingModifications();
			}
			return args;
		}
	}

	private void RunAwaitingModifications()
	{
		lock (this.Handlers)
		{
			foreach (var (modification, handler) in this.AwaitingModifications)
			{
				switch (modification)
				{
					case ManagedEventsModification.Add:
						this.ActuallyAdd(handler);
						break;
					case ManagedEventsModification.Remove:
						this.ActuallyRemove(handler);
						break;
					default:
						throw new ArgumentOutOfRangeException();
				}
			}
			this.AwaitingModifications.Clear();
		}
	}

	private record struct ManagedEventHandler(
		IModManifest Mod,
		EventHandler<TEventArgs> Handler
	);

	private enum ManagedEventsModification
	{
		Add, Remove
	}
}
